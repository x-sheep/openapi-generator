// APIHelper.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

internal struct APIHelper {
    internal static func rejectNil<Value>(_ source: [String: Value?]) -> [String: Value]? {
        let destination = source.reduce(into: [String: Value]()) { result, item in
            if let value = item.value {
                result[item.key] = value
            }
        }

        if destination.isEmpty {
            return nil
        }
        return destination
    }

    internal static func rejectNilHeaders(_ source: [String: ParameterField?]) -> [String: String] {
        return source.reduce(into: [String: String]()) { result, item in
            guard let value = item.value else { return }
            
            switch value {
            case .array(let collection):
                result[item.key] = collection
                    .compactMap { $0.stringValue }
                    .joined(separator: ",")
            default:
                if let string = value.stringValue {
                    result[item.key] = string
                }
            }
        }
    }

    internal static func convertAnyToString(_ value: Any?) -> String? {
        guard let value = value else { return nil }
        if let value = value as? any RawRepresentable {
            return "\(value.rawValue)"
        } else {
            return "\(value)"
        }
    }

    internal static func mapValueToPathItem(_ source: Any) -> Any {
        if let collection = source as? [Any?] {
            return collection
                .compactMap { value in convertAnyToString(value) }
                .joined(separator: ",")
        } else if let value = source as? any RawRepresentable {
            return "\(value.rawValue)"
        }
        return source
    }

    /// maps all values from source to query parameters
    ///
    /// explode attribute is respected: collection values might be either joined or split up into separate key value pairs
    internal static func mapValuesToQueryItems(_ source: [String: (wrappedValue: ParameterField?, isExplode: Bool)]) -> [URLQueryItem]? {
        let destination = source.filter { $0.value.wrappedValue != nil }.reduce(into: [URLQueryItem]()) { result, item in
            if case .array(let collection) = item.value.wrappedValue {
                let collectionValues: [String] = collection.compactMap { $0.stringValue }

                if !item.value.isExplode {
                    result.append(URLQueryItem(name: item.key, value: collectionValues.joined(separator: ",")))
                } else {
                    collectionValues
                        .forEach { value in
                            result.append(URLQueryItem(name: item.key, value: value))
                        }
                }

            } else if let value = item.value.wrappedValue?.stringValue {
                result.append(URLQueryItem(name: item.key, value: value))
            }
        }

        if destination.isEmpty {
            return nil
        }
        return destination.sorted { $0.name < $1.name }
    }

    /// maps all values from source to query parameters
    ///
    /// collection values are always exploded
    internal static func mapValuesToQueryItems(_ source: [String: ParameterField?]) -> [URLQueryItem]? {
        let destination = source.filter { $0.value != nil }.reduce(into: [URLQueryItem]()) { result, item in
            if case .array(let collection) = item.value {
                let collectionValues: [String] = collection.compactMap { $0.stringValue }

                collectionValues
                    .forEach { value in
                        result.append(URLQueryItem(name: item.key, value: value))
                    }

            } else if let value = item.value?.stringValue {
                result.append(URLQueryItem(name: item.key, value: value))
            }
        }

        if destination.isEmpty {
            return nil
        }
        return destination.sorted { $0.name < $1.name }
    }
}
